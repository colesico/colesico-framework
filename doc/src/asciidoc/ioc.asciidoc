[[intro]]

== Colesico-IoC

Colesico-IoC is a simple, lightweight dependency injection container for Java 9 and above.

[[features]]

== Key features:

* Reflection is not used (code generation at compile time with AnnotationProcessor).
* Dependency injection is constructor-based only.
* No support for cyclic dependency resolving.
* Can be used as plugin-framework.
* Producers based instance creation configuration.
* Dependency injection configuration discovery at container start time (SPI based).
* Multiple dependency injection configurations support (e.g. for testing purpose).
* Out-of-the-box Singleton scope(single instance per container), Thread scope (instance per thread) support.
* Named injections support (@Named annotation).
* Classed injections support (@Classed annotation).
* Support for multiple dependency implementations (@Polyproduce).
* Injection point support (e.g. for Logger injection).
* Java 9+


== Ioc container

The Ioc container is used to obtain instances with injected dependencies.

Ioc container can be created with the builder:

----
IocBuilder iocBuilder = IocBuilder.get();
----

Builder is not thread safe. But Ioc container is thread safe and can be used in multithreaded environment.

Builder allows to create an Ioc containers configured for using in:

* production (slow container start, fast dependency injection at runtime)
* developing  (fast container start, slow dependency injection at runtime)
* testing  (slow container start, slow dependency injection at runtime, dependencies satisfaction and cyclic dependencies autocheck)

Default Ioc container creation will create the container configured for the production:

----
Ioc ioc = iocBuilder.build();
----

or with "shortcut" method:

----
Ioc ioc = IocBuilder.forProduction();
----

Testing purpose container creation example:

----
iocBuilder.mode(useContainer(ContainerType.LAZY).useRank(Rank.RANK_TEST));
Ioc ioc = iocBuilder.build();
----

or with "shortcut" method:

----
Ioc ioc = IocBuilder.forTesting();
----

Obtaining instances with injected dependencies is done using this methods:

* instance - returns class instance
* provider - returns class instance provider  (javax.inject.Provider<>), is used to "deferred" instance obtaining/creation.
* supplier - returns class instance supplier, is used to "deferred" instance obtaining/creation with the ability to pass a message.
* polysupplier  - returns chain of class instance suppliers (colesico.framework.ioc.Polysupplier<>)

To specify what instance to return, use the "keys":

* TypeKey - allows to specify instance class.
* NamedKey - allows to specify instance class and the named label
* ClassedKey - this is like the NamedKey but instead of a string label is used any class.

----
  MyBean defaultBean = ioc.instance(new TypeKey(MyBean.class), null);
  MyBean namedBean = ioc.instance(new NamedKey(MyBean.class,"AnyName"), null);
  MyBean defaultBean = ioc.instance(new ClassedKey(MyBean.class, AnyClass.class), null);
----

When injecting dependencies as a constructor parameters, each key corresponds to a specific annotation:

* TypeKey - no annotation.
* NamedKey - @Named
* ClassKey - @Classed

----
public class MyBeanHolder {

    private final MyBean defaultBean;
    private final MyBean namedBean;
    private final MyBean classedBean;

    public MyBeanHolder(MyBean defaultBean,
                       @Named("AnyName") MyBean namedBean,
                       @Classed(AnyClass.class) MyBean classedBean) {

        this.defaultBean = defaultBean;
        this.namedBean = namedBean;
        this.classedBean = classedBean;
    }
}
----


In the particular case to obtaining an instance from the Ioc container,
you can specify just an instance class. (it will be implicitly converted to TypeKey)

----
  MyBean defaultBean = ioc.instance(new TypeKey(MyBean.class),null);
  // OR:
  MyBean defaultBean = ioc.instance(MyBean.class);
----


== Producers

The IoC container "finds out" about classes for dependencies injection with the producers.
Producer defines the instance creation way. Producer it is a plain java class annotated with @Producer annotation.

Creating an instance of a class is defined in two ways:

* Add @Produce annotation on a producer class.
* Define producer's public method. 

@Produce annotation specifies an instance class. In this case, the Ioc container will instantiate the instance simply by calling: new MyClass (param1, paramN);

If you need custom logic to create an instance, you should to define a public producer method that should return the instance.
All public methods of the producer are considered as provider-methods of instances of classes and are used by the Ioc container when creating instances.

Producer example:

----
@Producer
@Produce(MyImplementation.class)
@Produce(MyClass.class)
public class MyProducer {

    // Produce instance of MyInterface  (MyImplementation implements MyInterface) 
    @Singleton
    public MyInterface getMyInstance(MyImplementation impl){
        return impl;
    }

    // Produce instance for named dependency
    @Named("mynamed")
    public MyInterface getMyNamedInstance(MyImplementation impl){
        return impl;
    }
    
    // Manual instance creation MyBean
    public MyBean getMyBean(MyClass dependency1, MyInterface dependency2){
        return new MyBean( dependency1, dependency2);
    }
}
----

== Polyproducing

@Polyproduce annotation allows to specify that the IoC container my supply multiple instances for the dependency.
If this annotation is not applied  to the producer method an attempt to define more than one instance producers (for
the same class) will fails with ambiguous dependency error.

----
@Producer
public class MyProducer {

    public MyInterface getMyInstance1(MyImpl1 impl){
        return impl;
    }

    // This is ambiguous producing of MyInterface
    public MyInterface getMyInstance2(){
        return new MyImpl2();
    }



    @Polyproduce
    public MyBean getMyBean1(MyBeanImpl impl){
            return impl;
    }

    // Here is no ambiguous producing because of @Polyproduce
    @Polyproduce
    public MyBean getMyBean2(){
        return new MyBeanImpl2();
    }

}
----

== Scopes

The framework supports out-of-the-box the following scopes of instances:

* @Singleton - so-called local singleton. One instance of class per Ioc container.
* @ThreadScoped - one instance of class per thread


To define the instance scope you must specify an scope annotation(@Singleton и др) either on the instance class or on the producer provider-method.

Example:

----
@Singleton
public class MyBean1 {}

public class MyBean2 {}

@Producer
@Produce(MyBean1.class)
public class MyProducer{
   
   @Singleton
   public MyBean2 getMyBean2(){
      return new MyBean2();
   }
}
----

In this example the Instances of both classes MyBean1 and MyBean2 are singletones.

== Ranks

To be able to override the creation of instances the mechanism of ranks of producers is used.  
For example, for testing, using stubs, etc., or for plugins that override any functionality.

Each producer has a certain rank. If several producers "produce" instances of the same class,
then the Ioc container to create the instance will use the producer with a higher rank.

The priority of rank  is set by the IoC container builder.

By default, the builder uses the following ranks:

    * "minor" for low-priority producers
    * "default" for producers without an explicit specified rank
    * "extension" for extension producers that overrides minor/default producers (plugins, etc)
    * "test" for testing purposes when using stubs, etc.
    
"minor" - rank with the lowest priority, "test" - the highest priority.

The Ioc container builder allows to create any chain of ranks.
The rank itself is an simple arbitrary text string.

== Injectable constuctors

Classes for  dependency injection may not have an explicitly defined constructor. Ioc container will use the default constructor to create instances.
If more than one constructor is declared, the one that will be used for dependency injection must be annotated
with @Inject annotation, otherwise the Ioc container will use the first one in the class.
If the constructor is the only the @Inject annotation is optional.

The constructor parameters can be annotated with the @Named annotation (for named dependencies)


== Messages

The messages is a instance supplying conception when it is possible to pass any object as parameter for instance creation.
For example this may be used for Logger creation with passing an InjectionPoint information.

To obtain message in producing method use @Message annotation:

----
@Producer
public class MyProducer{

   public MyBean getMyBean(@Message MyMessage message){
      return new MyBeanImpl(message);
   }

}
----

To pass message for instance creation use the Supplier<T>

----
  public constructor(Supplier<MyBean> myBeanSup){
        MyMessage message = new MyMessage(...);
        MyBean myBean = myBeanSup.get(message);
  }
----

Or with IoC directly:

----
  MyMessage message = new MyMessage(...);
  MyBean myBean = ioc.instance(new TypeKey(MyBean.class), message);
----

== Maven pom.xml

Specify dependence:

----
        <dependency>
            <groupId>colesico.framework</groupId>
            <artifactId>colesico-ioc</artifactId>
            <version>${colesico.version}</version>
        </dependency>
----

Specify annotation processor:

----
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>colesico.framework</groupId>
                            <artifactId>colesico-ioc</artifactId>
                            <version>${colesico.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>        
        
----

== Run an application with plugins discovering at startup.

Ioc container discovers producers with  ServiceLoader.
If the application consists of several files (in lib/* dir.)  and the another files (e.g. plugins, modules etc) will be added later 
without rebuilding the main project, in order the Ioc container can discover the all providers in these separate jar files run the application with a command:

----
java -cp lib/*;myapp-1.0.jar my.app.Main
----

When run by a command like:

----
 java -jar  myapp-1.0.jar
----
 
producers in external jar files in the folder lib/* will not be discovered.

