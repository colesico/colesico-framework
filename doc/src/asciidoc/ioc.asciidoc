[[intro]]

== Colesico-IoC

Colesico-IoC is a simple, lightweight dependency injection container for Java 11 and above.

[[features]]

== Key features:

* Small codebase.
* Reflection is not used (code generation at compile time with AnnotationProcessor).
* Dependency injection is constructor-based only.
* Cyclic dependency resolving support.
* Can be used as plugin-framework.
* Producers based instance creation configuration.
* Dependency injection configuration discovery at container start time (SPI based).
* Multiple dependency injection configurations support (e.g. for testing purpose).
* Out-of-the-box Singleton scope(single instance per container), Thread scope (instance per thread) support.
* Named injections support (@Named annotation).
* Classed injections support (@Classed annotation).
* Support for multiple dependency implementations (@Polyproduce).
* Injection point support (e.g. for Logger injection).
* Lifecycle listeners  (@PostConstruct, @PostProduce)
* Java 11+  (JPMS compatible)


== Ioc container

The Ioc container is used to obtain instances with injected dependencies.

Ioc container can be created with the builder:

[source,java]
----
IocBuilder iocBuilder = IocBuilder.create();
----

Builder is not thread safe. But Ioc container is thread safe and can be used in multithreaded environment.
To create IoC container from builder:

[source,java]
----
Ioc ioc = iocBuilder.build();
----

Or just simple:

[source,java]
----
Ioc ioc = IocBuilder.create().build();
----

Obtaining instances with injected dependencies is done using this methods:

* instance - returns class instance
* provider - returns class instance provider  (javax.inject.Provider<>), is used to "deferred" instance obtaining/creation.
* supplier - returns class instance supplier, is used to "deferred" instance obtaining/creation with the ability to pass a message.
* polysupplier  - returns chain of class instance suppliers (colesico.framework.ioc.production.Polysupplier<>)

To specify what instance to return, use the "keys":

* TypeKey - allows to specify instance class.
* NamedKey - allows to specify instance class and the named label
* ClassedKey - this is like the NamedKey but instead of a string label is used any class.

----
  MyBean defaultBean = ioc.instance(new TypeKey(MyBean.class), null);
  MyBean namedBean = ioc.instance(new NamedKey(MyBean.class,"AnyName"), null);
  MyBean classedBean = ioc.instance(new ClassedKey(MyBean.class, AnyClass.class), null);
----

When injecting dependencies to a constructor  each key corresponds to a specific annotation:

* TypeKey - no annotation.
* NamedKey - @Named
* ClassKey - @Classed

[source,java]
----
public class MyBeanHolder {

    private final MyBean defaultBean;
    private final MyBean namedBean;
    private final MyBean classedBean;

    public MyBeanHolder(MyBean defaultBean,
                       @Named("AnyName") MyBean namedBean,
                       @Classed(AnyClass.class) MyBean classedBean) {

        this.defaultBean = defaultBean;
        this.namedBean = namedBean;
        this.classedBean = classedBean;
    }
}
----


In the particular case to obtaining an instance from the Ioc container,
you can specify just an instance class. (it will be implicitly converted to TypeKey)

[source,java]
----
  MyBean defaultBean = ioc.instance(new TypeKey(MyBean.class),null);
  // OR:
  MyBean defaultBean = ioc.instance(MyBean.class);
----


== Producers

The IoC container "finds out" about classes for dependencies injection with the producers.
Producer defines the instance creation way. Producer it is a plain java class annotated with @Producer annotation.

Creating an instance of a class is defined in two ways:

* Add @Produce annotation on a producer class.
* Define producer's public method. 

@Produce annotation specifies an instance class. In this case, the Ioc container will instantiate the instance simply by calling: new MyClass (param1, paramN);

If you need custom logic to create an instance, you should to define a public producer method that should return the instance.
All public methods of the producer are considered as provider-methods of instances of classes and are used by the Ioc container when creating instances.

Producer example:

[source,java]
----
@Producer
@Produce(MyImplementation.class)
@Produce(MyClass.class)
public class MyProducer {

    // Produce instance of MyInterface  (MyImplementation implements MyInterface) 
    @Singleton
    public MyInterface getMyInstance(MyImplementation impl){
        return impl;
    }

    // Produce instance for named dependency
    @Named("mynamed")
    public MyInterface getMyNamedInstance(MyImplementation impl){
        return impl;
    }
    
    // Manual instance creation MyBean
    public MyBean getMyBean(MyClass dependency1, MyInterface dependency2){
        return new MyBean( dependency1, dependency2);
    }
}
----

== Polyproducing

@Polyproduce annotation allows to specify that the IoC container may supply multiple instances for the dependency.
If this annotation is not applied  to the producer method an attempt to define more than one instance producers (for
the same class) will fails with ambiguous dependency error.

[source,java]
----
@Producer
public class MyProducer {

    public MyInterface getMyInstance1(MyImpl1 impl){
        return impl;
    }

    // This is ambiguous producing of MyInterface
    public MyInterface getMyInstance2(){
        return new MyImpl2();
    }



    @Polyproduce
    public MyBean getMyBean1(MyBeanImpl impl){
            return impl;
    }

    // Here is no ambiguous producing because of @Polyproduce
    @Polyproduce
    public MyBean getMyBean2(){
        return new MyBeanImpl2();
    }

}
----

== Scopes

The framework supports out-of-the-box the following scopes of instances:

* @Singleton - so-called local singleton. One instance of class per Ioc container.
* @ThreadScoped - one instance of class per thread


To define the instance scope you must specify an scope annotation(@Singleton и др) either on the instance class or on the producer provider-method.

Example:

[source,java]
----

@Singleton
public class MyBean1 {}

public class MyBean2 {}

@Producer
@Produce(MyBean1.class)
public class MyProducer{
   
   @Singleton
   public MyBean2 getMyBean2(){
      return new MyBean2();
   }
}
----

In this example the Instances of both classes MyBean1 and MyBean2 are singletones.

== Ranks

Ranks acts like a Spring framework DI profile conception.

To be able to override the creation of instances the mechanism of ranks of producers is used.  
For example, for testing, using stubs, etc., or for plugins that override any functionality.

Each producer has a certain rank. If several producers "produce" instances of the same class,
then the Ioc container to create the instance will use the producer with a higher rank.

The priority of rank  is set by the IoC container builder.

By default, the builder uses the following ranks:

* "minor" for low-priority producers
* "default" for producers without an explicit specified rank
* "extension" for extension producers that overrides minor/default producers (plugins, etc)
* "test" for testing purposes when using stubs, etc.
    
"minor" - rank with the lowest priority, "test" - the highest priority.

The Ioc container builder allows to create any chain of ranks.
The rank itself is an simple arbitrary text string.

== Injectable constructors

Classes for  dependency injection may not have an explicitly defined constructor. Ioc container will use the default constructor to create instances.
If more than one constructor is declared, the one that will be used for dependency injection must be annotated
with @Inject annotation, otherwise the Ioc container will use the first one in the class.
If the constructor is the only the @Inject annotation is optional.

The constructor parameters can be annotated with the @Named annotation (for named dependencies)


== Messages

The messages is a instance supplying conception when it is possible to pass any object as parameter for instance creation.
For example this may be used for Logger creation with passing an InjectionPoint information.

To obtain message in producing method use @Message annotation:

[source,java]
----

@Producer
public class MyProducer{

   public MyBean getMyBean(@Message MyMessage message){
      return new MyBeanImpl(message);
   }

}
----

To pass message for instance creation use the Supplier<T>

[source,java]
----

  public constructor(Supplier<MyBean> myBeanSup){
        MyMessage message = new MyMessage(...);
        MyBean myBean = myBeanSup.get(message);
  }
  
----

Or with IoC directly:

----
  MyMessage message = new MyMessage(...);
  MyBean myBean = ioc.instance(new TypeKey(MyBean.class), message);
----

== Injection point

In some cases it is useful to know the target class where the dependency is injected.
For example it may be required for the Logger injection.
To pass Injection point information to dependency producer use @Contextual annotation and to
obtain that Injection point in the producer use @Message annotation and InjectionPoint type parameter.
See logger injection detail example in the ioc-example source code.

== Lifecycle listeners

IoC container supports the following lifecycle listeners:

* PostConstruct. The bean public method annotated with @PostConstruct annotation will be
  invoked by the IoC container  after bean has been created and PostProduce listener been invoked.
* PostProduce. @PostProduce annotation should be applied to public producer method to declare post produce listener.
  The post produce listener is invoked by IoC container to handle just produced instance.
  Post produce listener invoked before @PostConstruct listener.

== Circular dependencies

In case of circular dependencies use Provider<Type> instead of direct instance injection.

[source,java]
----

  public constructor(Provider<T> dependencyProvider){
        ...
  }

----

== Conditional dependencies

 To define conditional instance producing for example for test cases use @Requires annotation.
 It allows to specify Condition class that be used to  make a desission to include producing factory to IoC Containner.

== Maven pom.xml

Specify dependence:

----
        <dependency>
            <groupId>net.colesico.framework</groupId>
            <artifactId>colesico-ioc</artifactId>
            <version>${colesico.version}</version>
        </dependency>
----

Specify annotation processor:

----
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>net.colesico.framework</groupId>
                            <artifactId>colesico-ioc</artifactId>
                            <version>${colesico.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>        
        
----

== Run an application with plugins discovering at startup.

Ioc container discovers producers with  ServiceLoader.
If the application consists of several files (in lib/* dir.)  and the another files (e.g. plugins, modules etc) will be added later without rebuilding the main project, in order the Ioc container can discover the all providers in these separate jar files run the application with a command:

----
java -cp lib/*;myapp-1.0.jar my.app.Main
----

When run by a command like:

----
 java -jar  myapp-1.0.jar
----
 
IoC producers in external jar files in the folder lib/* that added without rebuilding the project will not be discovered.

== Examples

See full source code in the framework source code section #examples/ioc-example#


